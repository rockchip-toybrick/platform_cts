/**
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "sac_bitdec.h"
#include "sac_dec_conceal.h"
#include <iostream>

#define MAX_PARAMETER_SETS (9)
#define MAX_NUM_OTT (5)

#define RETURN_EXIT_FAILURE_IF_NULL(ptr)                                       \
  {                                                                            \
    if (!ptr) {                                                                \
      return freeAllocatedMemoryAndReturn(frame, decoder, EXIT_FAILURE);       \
    }                                                                          \
  }

typedef signed char SCHAR;

int freeAllocatedMemoryAndReturn(SPATIAL_BS_FRAME *frame, spatialDec *decoder,
                                 int errorCode) {
  if (frame) {
    if (frame->CLDLosslessData) {
      for (int i = 0; i < MAX_NUM_OTT; ++i) {
        if ((&frame->CLDLosslessData[i])->state) {
          free((&frame->CLDLosslessData[i])->state);
          (&frame->CLDLosslessData[i])->state = nullptr;
        }
      }
      free(frame->CLDLosslessData);
      frame->CLDLosslessData = nullptr;
    }
    if (frame->ICCLosslessData) {
      free(frame->ICCLosslessData);
      frame->ICCLosslessData = nullptr;
    }
    if (frame->IPDLosslessData) {
      free(frame->IPDLosslessData);
      frame->IPDLosslessData = nullptr;
    }
    free(frame);
    frame = nullptr;
  }

  if (decoder) {
    if (decoder->pConfigCurrent) {
      free(decoder->pConfigCurrent);
      decoder->pConfigCurrent = nullptr;
    }
    if (decoder->ottCLDidxPrev) {
      free(decoder->ottCLDidxPrev);
      decoder->ottCLDidxPrev = nullptr;
    }
    if (decoder->smgTime) {
      free(decoder->smgTime);
      decoder->smgTime = nullptr;
    }
    if (decoder->smgData) {
      free(decoder->smgData);
      decoder->smgData = nullptr;
    }
    if (decoder->smoothState) {
      free(decoder->smoothState);
      decoder->smoothState = nullptr;
    }
    free(decoder);
    decoder = nullptr;
  }
  return errorCode;
}

int main() {
  spatialDec *decoder = (spatialDec *)malloc(sizeof(spatialDec));
  if (!decoder) {
    return EXIT_FAILURE;
  }
  SPATIAL_BS_FRAME *frame =
      (SPATIAL_BS_FRAME *)malloc(sizeof(SPATIAL_BS_FRAME));

  RETURN_EXIT_FAILURE_IF_NULL(frame);
  memset(frame, 0x00, sizeof(SPATIAL_BS_FRAME));

  RETURN_EXIT_FAILURE_IF_NULL(decoder);
  memset(decoder, 0x00, sizeof(spatialDec));

  size_t allocSize = sizeof(LOSSLESSDATA) * MAX_NUM_OTT * MAX_NUM_PARAMETERS;

  frame->CLDLosslessData = (LOSSLESSDATA *)malloc(allocSize);
  RETURN_EXIT_FAILURE_IF_NULL(frame->CLDLosslessData);
  memset(frame->CLDLosslessData, 0x00, allocSize);

  frame->ICCLosslessData = (LOSSLESSDATA *)malloc(allocSize);
  RETURN_EXIT_FAILURE_IF_NULL(frame->ICCLosslessData);
  memset(frame->CLDLosslessData, 0x00, allocSize);

  frame->IPDLosslessData = (LOSSLESSDATA *)malloc(allocSize);
  RETURN_EXIT_FAILURE_IF_NULL(frame->IPDLosslessData);
  memset(frame->CLDLosslessData, 0x00, allocSize);

  frame->numParameterSets = MAX_PARAMETER_SETS;

  for (int i = 0; i < MAX_NUM_OTT; ++i) {
    (&frame->CLDLosslessData[i])->state = nullptr;
    for (int j = 0; j < MAX_PARAMETER_SETS; ++j) {
      (&frame->CLDLosslessData[i])->bsXXXDataMode[j] = 2;
    }
    (&frame->CLDLosslessData[i])->state =
        (LOSSLESSSTATE *)malloc(sizeof(LOSSLESSSTATE));
    RETURN_EXIT_FAILURE_IF_NULL((&frame->CLDLosslessData[i])->state);
    memset((&frame->CLDLosslessData[i])->state, 0x00, sizeof(LOSSLESSSTATE));
  }

  decoder->numOttBoxes = MAX_NUM_OTT;

  decoder->pConfigCurrent =
      (SPATIAL_SPECIFIC_CONFIG *)malloc(sizeof(SPATIAL_SPECIFIC_CONFIG));
  RETURN_EXIT_FAILURE_IF_NULL(decoder->pConfigCurrent);
  memset(decoder->pConfigCurrent, 0x00, sizeof(SPATIAL_SPECIFIC_CONFIG));

  decoder->ottCLDidxPrev = (SCHAR **)malloc(sizeof(SCHAR *));
  RETURN_EXIT_FAILURE_IF_NULL(decoder->ottCLDidxPrev);
  memset(decoder->ottCLDidxPrev, 0x00, sizeof(SCHAR *));

  decoder->smgTime = (int *)malloc(sizeof(int));
  RETURN_EXIT_FAILURE_IF_NULL(decoder->smgTime);
  memset(decoder->smgTime, 0x00, sizeof(int));

  decoder->smgData = (UCHAR **)malloc(sizeof(UCHAR *));
  RETURN_EXIT_FAILURE_IF_NULL(decoder->smgData);
  memset(decoder->smgData, 0x00, sizeof(UCHAR *));

  decoder->smoothState = (SMOOTHING_STATE *)malloc(sizeof(SMOOTHING_STATE));
  RETURN_EXIT_FAILURE_IF_NULL(decoder->smoothState);
  memset(decoder->smoothState, 0x00, sizeof(SMOOTHING_STATE));

  decoder->arbitraryDownmix = 0;
  (decoder->concealInfo).concealState = SpatialDecConcealState_Ok;

  SpatialDecDecodeFrame(decoder, frame);
  return freeAllocatedMemoryAndReturn(frame, decoder, EXIT_SUCCESS);
}
